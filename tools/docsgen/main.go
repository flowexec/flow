//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"slices"
	"strings"
	"text/template"

	"github.com/jahvon/flow/cmd"
	"github.com/jahvon/flow/config"
)

const (
	DocsDir                    = "docs"
	ConfigDir                  = "config"
	DescriptionDecoratorPrefix = "+docsgen"
	ConfigIndexFilename        = "config.md"
)

const (
	configDocTemplate = `
[comment]: # (Documentation autogenerated by docsgen. Do not edit directly.)

# {{.Title}}

{{.Summary}}

{{range .Blocks}}
-------

{{.Str}}

{{end}}
`
	structTemplate = `## {{.Name}}

**Type**: Object

{{.Description}}

### Fields

| Key | Type | Description |
| ---- | ---- | ----------- |
{{range .Fields}}| {{.Tag}} | {{ if .Linkable }}[{{.Name}}](#{{.Name}}){{ else }}{{.Type}}{{ end }} | {{ if .Linkable }}{{ else }}{{.Description}}{{ end }} |
{{end}}
`
	primativeTemplate = `## {{.Name}}

**Type**: {{.Type}}

{{.Description}}
`
	configIndexTemplate = `# Flow Configuration Reference

## Table of Contents

{{range .}}
- [{{.Title}}](#{{.Title}})
{{end}}
`
)

type Block struct {
	Str string
}

type ConfigDocumentation struct {
	Filename string
	Title    string
	Summary  string
	Types    []any
	Blocks   []Block
}

var (
	_, b, _, _ = runtime.Caller(0)
	Root       = filepath.Join(filepath.Dir(b), "../..")
	ConfigDocs = []ConfigDocumentation{
		{
			Filename: "user_config.md",
			Title:    "User Config",
			Summary: "The user config is used by Flow to configure Flow user-specific settings.\n" +
				"This config is stored in the user's flow cache directory (e.g. `$HOME/Library/Application Support/flow` on MacOS). ",
			Types: []any{
				&config.UserConfig{},
			},
		},
		{
			Filename: "workspace_config.md",
			Title:    "Workspace Config",
			Summary: "The workspace config is used to store Flow workspace-specific configuration.\n" +
				"Every workspace has a workspace config file named `flow.yaml` in the root of the workspace directory.",
			Types: []any{
				&config.WorkspaceConfig{},
			},
		},
		{
			Filename: "executables.md",
			Title:    "Executables",
			Summary: "The executable definition files are used to define Flow executables.\nA workspace can have multiple " +
				"executable definition files. Each executable definition file can define multiple executables. " +
				"Each executable definition file must have the extension `.flow` to be discoverable by Flow. " +
				"These files can be located anywhere in the workspace directory.",
			Types: []any{
				&config.ExecutableDefinition{},
				&config.ExecutableDefinitionTemplate{},
				&config.Executable{},
				&config.Argument{},
				&config.Parameter{},
				new(config.Ref),
				new(config.Verb),
				&config.ExecExecutableType{},
				&config.LaunchExecutableType{},
				&config.RequestExecutableType{},
				&config.RenderExecutableType{},
				&config.SerialExecutableType{},
				&config.ParallelExecutableType{},
			},
		},
	}
)

func main() {
	fmt.Println("Generating CLI docs...")
	if err := cmd.GenerateMarkdownTree(filepath.Join(Root, DocsDir, "cli")); err != nil {
		panic(err)
	}

	fmt.Println("Generating config docs...")
	generateConfigDocs(filepath.Join(Root, DocsDir, "config"))
}

func generateConfigDocs(dir string) {
	for _, d := range ConfigDocs {
		var buf bytes.Buffer
		tmpl, err := template.New("doc").Parse(configDocTemplate)
		if err != nil {
			panic(err)
		}

		for _, t := range d.Types {
			reflectedType := reflect.TypeOf(t).Elem()
			switch reflectedType.Kind() {
			case reflect.Struct:
				markdown := structToMarkdown(reflectedType)
				d.Blocks = append(d.Blocks, Block{Str: markdown})
			case reflect.String:
				markdown := primativeToMarkdown(reflectedType)
				d.Blocks = append(d.Blocks, Block{Str: markdown})
			default:
				panic(fmt.Errorf("unsupported type %s", reflectedType.Kind()))
			}
		}

		if err := tmpl.Execute(&buf, d); err != nil {
			panic(err)
		}
		markdown := buf.String()

		filePath := filepath.Join(dir, d.Filename)
		file, err := os.Create(filePath)
		if err != nil {
			panic(err)
		}
		defer file.Close()
		if _, err := file.WriteString(markdown); err != nil {
			panic(err)
		}
	}

	var buf bytes.Buffer
	tmpl, err := template.New("index").Parse(configIndexTemplate)
	if err != nil {
		panic(err)
	}
	if err := tmpl.Execute(&buf, ConfigDocs); err != nil {
		panic(err)
	}
	markdown := buf.String()
	filePath := filepath.Join(dir, ConfigIndexFilename)
	file, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer file.Close()
	if _, err := file.WriteString(markdown); err != nil {
		panic(err)
	}
}

type fieldData struct {
	Name        string
	Tag         string
	Description string
	Type        string
	Linkable    bool
	goType      reflect.Type
}

type structData struct {
	Name        string
	Tag         string
	Description string
	Fields      []fieldData
}

func structFieldData(t reflect.Type) []fieldData {
	fields := []fieldData{}
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}
		tag, opts, found := strings.Cut(field.Tag.Get("yaml"), ",")
		if !found {
			tag = field.Tag.Get("yaml")
		}
		if strings.Contains(opts, "inline") {
			inlineType := field.Type
			if inlineType.Kind() == reflect.Struct {
				fields = append(fields, structFieldData(inlineType)...)
			} else if inlineType.Kind() == reflect.Ptr {
				inlineType = inlineType.Elem()
				if inlineType.Kind() == reflect.Struct {
					fields = append(fields, structFieldData(inlineType)...)
				}
			}
			continue
		}
		if field.PkgPath == "" {
			switch field.Type.Kind() {
			case reflect.String:
				typeStr := "String"
				var linkable bool
				if field.Type.Name() != "string" {
					typeStr = field.Type.Name()
					linkable = true
				}
				fields = append(fields, fieldData{
					Name:        field.Name,
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        typeStr,
					Linkable:    linkable,
					goType:      field.Type,
				})
			case reflect.Bool:
				fields = append(fields, fieldData{
					Name:        field.Name,
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        "Boolean",
					goType:      field.Type,
				})
			case reflect.Int:
				fields = append(fields, fieldData{
					Name:        field.Name,
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        "Integer",
					goType:      field.Type,
				})
			case reflect.Struct:
				fields = append(fields, fieldData{
					Name:        field.Name,
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        "Object",
					Linkable:    true,
					goType:      field.Type,
				})
			case reflect.Slice:
				of := field.Type.Elem()
				if of.Kind() == reflect.Ptr {
					of = of.Elem()
				}
				fields = append(fields, fieldData{
					Name:        field.Name,
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        fmt.Sprintf("Array (%s)", linkTypeString(of.Name())),
					goType:      field.Type,
				})
			case reflect.Map:
				key := field.Type.Key()
				value := field.Type.Elem()
				if key.Kind() == reflect.Ptr {
					key = key.Elem()
				}
				if value.Kind() == reflect.Ptr {
					value = value.Elem()
				}
				fields = append(fields, fieldData{
					Name:        field.Name,
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        fmt.Sprintf("Map (%s -> %s)", linkTypeString(key.Name()), linkTypeString(value.Name())),
					goType:      field.Type,
				})
			case reflect.Ptr:
				elem := field.Type.Elem()
				fields = append(fields, fieldData{
					Name:        elem.Name(),
					Tag:         tag,
					Description: descriptionFromFile(tag),
					Type:        "Object",
					Linkable:    true,
					goType:      field.Type,
				})
			}
		}
	}
	return fields
}

func structToMarkdown(t reflect.Type) string {
	name := t.Name()
	description := descriptionFromFile(strings.ToLower(name))
	fields := structFieldData(t)
	tmpl, err := template.New("struct").Parse(structTemplate)
	if err != nil {
		panic(err)
	}

	data := structData{
		Name:        name,
		Description: description,
		Fields:      fields,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(err)
	}
	objectData := buf.String()

	slices.SortFunc(fields, func(i, j fieldData) int {
		return strings.Compare(i.Name, j.Name)
	})
	for _, field := range fields {
		if !field.Linkable {
			continue
		}
		if field.Type == "Object" {
			tmpl, err = template.New("struct").Parse(structTemplate)
			if err != nil {
				panic(err)
			}
			data := structData{
				Name:        field.Name,
				Description: field.Description,
				Fields:      structFieldData(field.goType),
			}
			var buf bytes.Buffer
			if err := tmpl.Execute(&buf, data); err != nil {
				panic(err)
			}
			objectData += "\n-------\n" + buf.String()
		} else {
			tmpl, err = template.New("primative").Parse(primativeTemplate)
			if err != nil {
				panic(err)
			}
			data := fieldData{
				Name:        field.Name,
				Description: field.Description,
				Tag:         field.Tag,
				Type:        field.Type,
			}
			var buf bytes.Buffer
			if err := tmpl.Execute(&buf, data); err != nil {
				panic(err)
			}
			objectData += "\n-------\n" + buf.String()
		}
	}

	return objectData
}

func primativeToMarkdown(t reflect.Type) string {
	name := t.Name()
	description := descriptionFromFile(strings.ToLower(name))
	tmpl, err := template.New("primative").Parse(primativeTemplate)
	if err != nil {
		panic(err)
	}

	data := fieldData{
		Name:        name,
		Description: description,
		Type:        name,
		Tag:         strings.ToLower(name),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(err)
	}
	return buf.String()
}

func descriptionFromFile(tag string) string {
	path := filepath.Join(Root, ConfigDir)
	fset := token.NewFileSet()
	d, err := parser.ParseDir(fset, path, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	for _, pkg := range d {
		for _, f := range pkg.Files {
			for _, c := range f.Comments {
				text := c.Text()
				if strings.HasPrefix(text, DescriptionDecoratorPrefix) {
					re := regexp.MustCompile(`\+docsgen:(\S+)`)
					match := re.FindStringSubmatch(text)
					if len(match) == 2 {
						if match[1] == tag {
							cutSize := len(DescriptionDecoratorPrefix) + len(match[1]) + 1
							str := strings.TrimSpace(text[cutSize:])
							str = strings.Replace(str, "\n", "<br>", -1)
							return str
						}
					}
				}
			}
		}
	}
	return ""
}

func linkTypeString(t string) string {
	switch t {
	case "string", "bool", "int":
		return t
	default:
		return fmt.Sprintf("[%s](#%s)", t, t)
	}
}
